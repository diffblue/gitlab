# frozen_string_literal: true

module Gitlab
  module Llm
    module Templates
      class ExplainVulnerability
        include Gitlab::Utils::StrongMemoize

        MAX_CODE_LENGTH = 1_024
        MAX_TOKENS = 3_000
        SECRET_PATTERNS = [
          /secret/i,
          /key/i,
          /ENV/i,
          /[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}/i,
          /token/i,
          /'Bearer\s[\d|a-f]{8}-([\d|a-f]{4}-){3}[\d|a-f]{12}'/i,
          /password/i,
          /encrypted/i,
          /encryption/i,
          /email/i,
          /authorisation/i,
          /authorization/i,
          /session/i,
          /cert/i,
          /jwt/i,
          /otp/i,
          /signing/i,
          /dsn/i,
          /trace/i
        ].freeze

        def initialize(vulnerability)
          @vulnerability = vulnerability
        end

        def options(client)
          return {} unless client == ::Gitlab::Llm::OpenAi::Client

          { max_tokens: MAX_TOKENS }
        end

        def to_prompt
          return prompt_without_file_or_code unless file.present?
          return prompt_without_code unless eligible_code?

          default_prompt
        end

        private

        attr_reader :vulnerability

        delegate :title, :description, :file, to: :vulnerability
        delegate :source_code?, :vulnerable_code, to: :finding

        # In case of possible secret patterns in the code snippet, we aggressively
        # ban certain patterns until a better solution is in place.
        # See https://gitlab.com/gitlab-org/gitlab/-/issues/413112
        def unsafe_code?
          SECRET_PATTERNS.any? do |pattern|
            pattern.match?(vulnerable_code)
          end
        end

        # rubocop: disable CodeReuse/ActiveRecord
        def identifiers
          finding.identifiers.pluck(:name).join(", ")
        end
        # rubocop: enable CodeReuse/ActiveRecord

        def finding
          vulnerability.finding
        end
        strong_memoize_attr :finding

        def filename
          File.basename(file)
        end

        def eligible_code?
          return false unless source_code?
          return false if vulnerable_code.length > MAX_CODE_LENGTH
          return false if vulnerability.secret_detection?
          return false if unsafe_code?

          true
        end

        def default_prompt
          <<~PROMPT
          You are a software vulnerability developer.
          Explain the vulnerability "#{title} - #{description} (#{identifiers})".
          The file "#{filename}" has this vulnerable code:

          ```
          #{vulnerable_code}
          ```

          Provide a code example with syntax highlighting on how an attacker can take advantage of the vulnerability.
          Provide a code example with syntax highlighting on how to fix it.
          Provide the response in markdown format with headers.
          PROMPT
        end

        def prompt_without_code
          <<~PROMPT
          You are a software vulnerability developer.
          Explain the vulnerability "#{title} - #{description} (#{identifiers})".
          The vulnerable code is in the file "#{filename}".
          Provide a code example with syntax highlighting on how an attacker can take advantage of the vulnerability.
          Provide a code example with syntax highlighting on how to fix it.
          Provide the response in markdown format with headers.
          PROMPT
        end

        def prompt_without_file_or_code
          <<~PROMPT
          You are a software vulnerability developer.
          Explain the vulnerability "#{title} - #{description} (#{identifiers})".
          Provide a code example with syntax highlighting on how an attacker can take advantage of the vulnerability.
          Provide a code example with syntax highlighting on how to fix it.
          Provide the response in markdown format with headers.
          PROMPT
        end
      end
    end
  end
end
