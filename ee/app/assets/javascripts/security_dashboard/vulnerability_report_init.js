import Vue from 'vue';
import { DASHBOARD_TYPES } from 'ee/security_dashboard/store/constants';
import { parseBoolean } from '~/lib/utils/common_utils';
import UnavailableState from './components/shared/empty_states/unavailable_state.vue';
import apolloProvider from './graphql/provider';
import createRouter from './router';
import createStore from './store';
import ProjectVulnerabilityReport from './components/project/project_vulnerability_report.vue';
import GroupVulnerabilityReport from './components/group/group_vulnerability_report.vue';
import InstanceVulnerabilityReport from './components/instance/instance_vulnerability_report.vue';

const getVulnerabilityComponent = (dashboardType) => {
  switch (dashboardType) {
    case DASHBOARD_TYPES.PROJECT:
      return ProjectVulnerabilityReport;
    case DASHBOARD_TYPES.GROUP:
      return GroupVulnerabilityReport;
    case DASHBOARD_TYPES.INSTANCE:
      return InstanceVulnerabilityReport;
    default:
      throw new Error('unknown_dashboard');
  }
};

export default (el, dashboardType) => {
  if (!el) {
    return null;
  }

  const {
    isUnavailable,
    dashboardDocumentation,
    emptyStateSvgPath,
    noVulnerabilitiesSvgPath,
    notEnabledScannersHelpPath,
    noPipelineRunScannersHelpPath,
    hasVulnerabilities,
    hasProjects,
    scanners,
    securityDashboardHelpPath,
    vulnerabilitiesExportEndpoint,
    projectFullPath,
    autoFixDocumentation,
    autoFixMrsPath,
    groupFullPath,
    instanceDashboardSettingsPath,
    pipelineCreatedAt,
    pipelineId,
    pipelinePath,
    pipelineSecurityBuildsFailedCount,
    pipelineSecurityBuildsFailedPath,
    hasJiraVulnerabilitiesIntegrationEnabled,
    operationalConfigurationPath,
    operationalEmptyStateSvgPath,
    operationalHelpPath,
    securityConfigurationPath,
    surveyRequestSvgPath,
    canAdminVulnerability,
    falsePositiveDocUrl,
    canViewFalsePositive,
  } = el.dataset;

  if (isUnavailable) {
    return new Vue({
      el,
      render(createElement) {
        return createElement(UnavailableState, {
          props: {
            link: dashboardDocumentation,
            svgPath: emptyStateSvgPath,
          },
        });
      },
    });
  }

  const provide = {
    dashboardType,
    dashboardDocumentation,
    noVulnerabilitiesSvgPath,
    emptyStateSvgPath,
    notEnabledScannersHelpPath,
    noPipelineRunScannersHelpPath,
    instanceDashboardSettingsPath,
    operationalConfigurationPath,
    operationalEmptyStateSvgPath,
    operationalHelpPath,
    securityDashboardHelpPath,
    securityConfigurationPath,
    surveyRequestSvgPath,
    vulnerabilitiesExportEndpoint,
    groupFullPath,
    projectFullPath,
    fullPath: projectFullPath || groupFullPath,
    autoFixDocumentation,
    autoFixMrsPath,
    canAdminVulnerability: parseBoolean(canAdminVulnerability),
    hasVulnerabilities: parseBoolean(hasVulnerabilities),
    hasProjects: parseBoolean(hasProjects),
    scanners: scanners ? JSON.parse(scanners) : [],
    hasJiraVulnerabilitiesIntegrationEnabled: parseBoolean(
      hasJiraVulnerabilitiesIntegrationEnabled,
    ),
    falsePositiveDocUrl,
    canViewFalsePositive: parseBoolean(canViewFalsePositive),
  };

  if (dashboardType === DASHBOARD_TYPES.PROJECT) {
    provide.pipeline = {
      createdAt: pipelineCreatedAt,
      id: pipelineId,
      path: pipelinePath,
      securityBuildsFailedCount: Number(pipelineSecurityBuildsFailedCount),
      securityBuildsFailedPath: pipelineSecurityBuildsFailedPath,
    };
  }

  const router = createRouter();
  const store = createStore({ dashboardType });

  return new Vue({
    el,
    store,
    router,
    apolloProvider,
    provide,
    render(createElement) {
      return createElement(getVulnerabilityComponent(dashboardType));
    },
  });
};
